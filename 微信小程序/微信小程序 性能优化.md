## 微信小程序 性能优化



### 启动性能

#### 代码包体积优化

1. 合理使用分包加载
2. 避免非必要的全局自定义组件和插件
3. 控制代码包内资源文件
4. 及时清理无用代码和资源

#### 代码注入优化

1. 使用按需注入

> 仅注入当前页面需要的自定义组件和页面代码

​	通常情况下，在小程序启动是，启动页面依赖的所有代码包（主包，分包，插件包，代码库等）的所有js 代码会全部合并注入，包括其他未访问的页面和未用到的自定义组件，同时所有页面的自定义组件的js 代码会被立即执行，这造成很多没有使用的代码在小程序运行环境中注入执行，影响注入耗时和内存占用

``` javascript
{
  "lazyCodeLoading": "requiredComponent"
}
```

启用按需注入后， 页面 json 配置中定义的所有组件和 app.json 中 usingComponents 配置的全局自定义组件，都会被视为页面的依赖并进行注入和加载， 建议开发者即使移除 json 中未使用自定义组件的声明， 并尽量避免在全局声明使用率低的自定义组件，否则可能会影响按需注入的效果



2. 使用 用时注入

> 在渲染时再注入

在打开按需注入特性的前提下，可以通过用时注入特性 使一部分自定义组件不在启动时注入，而是在真正被渲染时才进行注入，进一步降低小程序的启动和首屏时间



3. 启动过程中减少同步 api 的调用

小程序启动流程中，会注入开发者代码并顺序同步执行 `App.onLaunch` `App.onShow` `Page.onLoad` `Page.onShow`

在小程序初始化代码和上述启动相关的几个声明周期中，应尽量减少或不调用同步 API ，绝大多数 同步API 会以 `Sync` 结尾， 但也有部分特例， 比如 ： `getSystemInfo`



4. 避免启动过程进行复杂运算

在小程序初始代码和启动相关的几个生命周期中，应**避免执行复杂的运算逻辑**，复杂的运算逻辑会阻塞当前js 线程，影响启动耗时，建议将复杂的运算延迟到启动完成后执行



#### 首屏渲染优化

**使用 按需注入 和 用时注入：**

除了优化代码注入的耗时外， 按需注入和用时注入也可以减少需要初始化的组件数量，降低实际页面渲染的耗时

> 启用按需注入后， 部分组件代码注入会被延迟到首页渲染阶段执行，导致阶段耗时上涨，但总耗时一般会下降



**启用 初始渲染缓存**

自基础库 2.11.1 起，小程序支持 初始渲染缓存, 开启后, 可以在非首次启动时，使视图层不需要等待逻辑层初始化完毕，直接将页面渲染结果展示给用户



**避免引用未使用的自定义组件**

在页面渲染时，会初始化在当前页面配置和全局配置通过 `suingComponent` 引用的自定义组件, 以及 组件所依赖的其他组件， 未使用的组件会影响渲染耗时





**精简首屏数据**

首页渲染耗时与页面复杂度正相关，对于复杂页面 ， 可以进行渐进式渲染，根据页面内容优先级，优先渲染一部分，其他数据延迟更新

此外与视图层无关的数据尽量不要放在data 中，避免影响渲染时间



**缓存数据请求**





**骨架屏**













#### 其他

**小程序更新机制：**开发者在管理后台发布新版小程序之后，微信客户端会有若干个时机去检查本地缓存的小程序有没有新版本，并进行小程序的代码更新，但如果用户本地有小程序的历史版本，此时打开的可能还是旧版本

**启动时同步更新**，在以下情况下， 小程序会同步更新代码包，同步更新会阻塞小程序的启动流程，影响小程序的启动耗时，如果更新失败或超时，为了保障小程序的可用性，还是会使用本地版本打开

1. 定期检查发现版本更新： 微信运行时，会检查最近使用的小程序是否有更新，如果有更新，下次小程序启动时会同步进行更新，更新到最新版本后再打开小程序，尽可能保证用户能够尽快使用小程序的最新版本。总的来说，开发者在发布新版本之后， 无法立刻影响到所有现网用户，但在最差情况下，也在发布 24 小时之内覆盖绝大多数用户
2. 用户长时间未使用小程序：用户长时间未使用小程序时，为保障小程序版本的实时性，会强制同步检查版本更新，更新到最新版本后再打开小程序

**启动时异步更新**，即使使用前未发现更新，小程序每次 冷启动 时，都会异步检查是否有更新版本，如果发现有新版本，将会异步下载新版本的代码包，但当次启动仍会使用客户端本地的旧代码。新版本小程序需等到 下一次冷启动才会使用









### 运行时性能

#### `setData` 优化

**setData** 的流程

* 逻辑层虚拟DOM树的遍历和更新， 触发生命周期和 observer 等
* 将data 从逻辑层传输到视图层
* 视图层虚拟DOM 树的更新， 真实DOM 元素的更新并触发页面渲染更新



由于小程序的逻辑层和视图层是两个独立运行的环境，分属于不同的线程和进程， 不能直接进行数据共享，需要进行数据的序列化，跨线程/进程 的数据传输，数据的反序列化， 因此数据传输过程是异步的，非实时的

> ios / ipadOs / macOs 上， 数据传输是通过 evaluateJavascript 实现的，还会有额外的 js 脚本解析和执行耗时

数据传输的耗时与数据量的大小正相关，对于端线程处于繁忙状态，数据会在消息队列中等待



**使用建议**

1. data 应只包括渲染相关的数据
2. 控制 setData 的频率
3. 选择合适的 setData 范围
4. setData 只应该传递发生变化的数据
5. 控制后台页面的 setData



**性能分析： 可通过组件的  `setUpdatePerformanceListener` 接口获取更新性能统计信息, 来分析产生性能瓶颈的组件**





#### 渲染性能优化

**适当监听页面或组件的scroll 事件**，只要用户在Page 构造时传入了 onPageScroll 监听，基础库就会认为开发者需要监听页面scroll 事件，此时，当用户滑动页面，事件就会很高频率地从视图层发送到逻辑层，存在一定的通信开销

正是由于scroll 事件触发的频率很高，使用时要注意：

1. 非必要不监听 scroll 事件
2. 在实现与滚动相关的动画时，优先考虑 [滚动驱动动画]() 或 [wxs响应事件]()
3. 不需要监听事件时，Page 构造时应不传入 onPageScroll 函数，而不是留空函数
4. 避免在scroll 事件监听函数中执行复杂逻辑
5. 避免在scroll 事件监听中频繁调用 setData 或 同步 API



**选择高性能动画实现方式：** 开发者在开发界面动画时，应该选择高性能动画实现方式：

1. 优先使用 css 渐变，css 动画，或小程序框架提供的其他动画实现方式去实现
2. 在一些复杂场景下，如果上述方式不能满足，可以使用  wxs响应事件 动态调整节点的style 属性做到动画效果，同时，这种方式也可以根据用户的触摸事件来动态地生成动画
3. 避免通过连续 `setData` 来改变界面的形式来实现动画，虽然实现起来简单灵活，但是极易出现较大的延迟或卡顿，甚至导致小程序僵死
4. 如果不得不采用 `setData` 的方式，应尽可能将页面的 setData 改为自定义组件中的setData 来提升性能



**使用 intersectionObserver 监听元素曝光：** 部分业务场景会需要监控元素曝光情况，用于进行一些页面状态的变更或上报分析

1. 建议使用 [节点布局相交状态监听 intersectionObserver]() 推断某些节点是否可见， 有多大比例可见
2. 避免通过监听 onPageScroll 事件， 并在回调中通过持续的 查询节点信息 SelectQuery 来判断元素是否可见



**控制WXML节点数量和层级：** 一个太大的WXML 节点树会增加内存的使用， 样式重排事件也会更长，影响体验，建议一个页面WXML节点数量应少于 1000个，节点数深度少于30层，子节点树不大于60个





**控制在 Page 构造时传入的自定义数据量：** 为了便于开发，开发者可以添加任意的函数或数据到 Page 构造传入的 Object 参数中， 并在页面的函数内用this 访问，例如：

```javascript
Page({
  data: {},
  userInfo: {}, // 自定义数据
  currentUser: 'wxApp', // 自定义数据
  onLoad() {}
})
```

为了保证自定义数据在不同的页面实例中也是不同的实例，小程序框架会在创建时对这部分数据（函数类型字段除外）做一次深拷贝，如果自定义数据过于复杂，可能带来很大开销

对于比较复杂的数据对象，建议在 `page onLoad` 或者  `component created` 时 手动赋值到this 上，而不是通过Page 构造时的参数传入

``` javascript
// 错误示例
Page({
  onLoad() {},
  bigData: {},
  longList: {}
})

// 正确示例
Page({
  onLoad() {
    this.bigData = {},
  	this.longList = {}
  }
})
```







#### 页面切换优化

触发页面切换的操作：

* `wx.navigateTo`
* `wx.navigateBack`
* `wx.redirectTo`
* `wx.relaunch`
* `wx.switchTab`
* 用户点击 `<navigator>` 组件进行页面切换
* 原生UI触发： 左上角返回按钮， 系统返回键， 左滑返回等
* 小程序热启动时的 自动 reLaunch



**加载分包（若有）**： 如果页面切换的目标页面在分包中，页面切换时需要下载分包，并且在逻辑层注入执行分包的JS 代码（小程序声明周期内，每个分包只会在逻辑层注入一次）



**视图层页面初始化：**

小程序的每个页面都是由独立的webview 渲染的，因此页面切换时需要一个新的webview 环境，视图层初始化主要会做一下事情：

* 创建 webview
* 注入视图层小程序基础库
* 注入主包的公共代码(独立分包注入独立分包的公共代码)
* 注入页面代码

为了降低视图层页面初始化消耗，在页面渲染完成后，通常会进行必要的预加载供页面切换时使用，预加载要做的事情包括：

* 创建webview
* 注入视图层小程序基础库
* 注入主包的公共代码(独立分包注入独立分包的公共代码)

> 若页面切换过快，或预加载环境被回收， 则需要在页面切换时重新创建环境

如果页面切换时 有预加载好的环境，可以大大降低页面切换的耗时

> 当切换的目标页面已经加载完成时， 不需要进行本阶段



**逻辑层页面初始化：**

完成分包加载和 webview 创建后，客户端会像基础库派发路由事件

基础库收到事件后会进行逻辑层页面初始化， 包括触发上一个页面的 `onHide / onUnload` 页面组件树初始化，更新页面栈并生成初始数据发送到视图层，并依次触发目标的 `onLoad`, `onShow` 声明周期，如果启用了 "按需注入"， 这一阶段还会注入页面代码

> 基础库收到事件的时间对应 Proformance(route) 中的 navigatioinStart,  对应 PerformanceEntry（firstRender） 的开始时间
>
> 当切换的目标页面已加载完成时， 不需进行页面组件树初始化和初始数据的发送，且不会触发目标页面的onLoad





**目标页面渲染：**

页面切换的目标不存在时， 会触发页面的首次渲染

在完成视图层代码注入，并收到逻辑层发送的初始数据后，结合从初始数据和视图层得到的页面结构和样式信息，小程序框架会进行页面渲染，并触发页面的 `onReady` 事件

> 视图层渲染完成， 触发页面 onReady事件的时间， 对应 PerformanceEntry（firstRender）的结束时间, 当 切换的目标页面加载完成时， 不需要要进行本阶段



**页面切换动画：**

页面渲染完成后，客户端会进行页面切换的动画（例如：从右向左推入页面），如果页面初始化和渲染事件超过固定时间，为避免用户以为页面无响应，页面会提前推入

> 页面推入动画完成的时间，对应 PerformanceEntry (route) 的结束时间



**如何优化页面切换：**

1. 避免在 `onHide / onUnload` 执行耗时操作（如果必须进行复杂逻辑，考虑用 setTimeout 延迟进行）
2. 首屏渲染优化，减少首屏渲染开销
3. 提前发起数据请求，从发起页面跳转到 onLoad 之间可能有较长的时间可以加以利用
4. 控制预加载下个页面的加载时机(仅安卓)

		* static: 默认值，当页面onReady 触发 200 ms 后触发预加载
		* auto:  渲染线程空闲时进行预加载，根据基础库 一段时间内 `requestAnimationFrame` 的触发频率算法判断
		* Manual： 通过开发者调用 `wx.preloadWebview` 触发，开发者可以在页面主要内容的setData 结束后手动触发





#### 资源加载优化

**控制图片资源的大小：**图片体积太大，可能导致： 

1. 增加图片的下载时间，导致用户看到图片时机延迟
2. 对用户造成非必要的流量消耗
3. 影响图片解码和绘制的耗时，可能更容易造成掉帧，卡顿或白屏，甚至无法正常进行滚动和页面切换
4. 内存占用增长，尤其是大图片和长列表中的大量图片会导致内存占用急剧上升



**图片对内存的影响：**ios系统内存紧张时，会主动回收一部分 webview，大图片和长列表中的大量图片很容易引起系统对 webview 的回收，导致小程序白屏，严重时会触发微信强制关闭小程序

内存增长如果超出了限制，也会导致小程序出现白屏或黑屏，甚至整个小程序发生闪退

**避免滥用image 组件的 widthFix / heightFix 模式：**

`widthFix / heightFix` 模式会在图片加载完成后，动态改变图片的高度和宽度，图片高度或宽度的动态改变，可能会引起页面内大范围的布局重排，导致页面发生抖动，并造成卡顿

对于页面的背景或 banner 图，应尽量预先指定图片的尺寸，避免图片加载完成后在进行二次的尺寸调整





#### 内存优化

**合理使用分包加载：** 使用分包加载不仅能优化启动耗时，也能够实现页面，组件和逻辑较粗粒度的按需加载，从而降低内存的占用



**使用按需注入和用时注入：** 通过开启 按需注入和用时注入，可以在运行时避免加载未使用的页面和组件，降低运行时的内存占用



**内存分析：**如果要更精细的分析小城功能需的逻辑层的内存分布情况，可以使用开发者工具调试器【内存调试】或 【真机调试2.0】提供的 【内存调试】能力



**处理内存警告：**当小程序占用系统过高，可能会被系统销毁或被微信客户端主动回收，在 IOS 上，当微信客户端在一定时间间隔内连续收到系统内存警告时，会根据一定策略，主动销毁小程序，并提示用户【运行内存不足，请重新打开小程序】

建议小程序在必要时使用 `wx.onMemoryWarning` 监听内存警告事件，进行必要的内存清理，例如： 释放一些暂时不用的组件或js对象



**小程序常见的内存泄露问题：** 存在内存泄露问题会导致小程序在运行过程中内存占用持续增长，引起小程序闪退或被微信强制销毁



**小程序长期持有页面实例，导致页面实例和引用的组件无法正常销毁：** 页面 `unload` 之后 ，基础库会从页面栈中将页面实例清理，正常情况下，js 垃圾回收机制会将页面进行回收，释放内存

但如果开发者代码中持有的页面实例（this）未释放，则会导致页面未被正常回收，引起内存泄露，建议开发者注意，并在 `unload` 中进行必要的清理



* 页面实例未被解绑的事件监听引用：

``` javascript
// 页面实例被未解绑的事件监听引用
// 事件监听器中持有了页面this，如果页面销毁后监听未解绑，会导致页面无法释放
Page({
  themeChangeHandler({theme}) {
    this.setData({theme})
  }
  onLoad() {
  	this._handler = this.themeChangeHandler.bind(this)
  	wx.onThemeChange(this._handler)
	}
	// 修复方法， unload 中解绑监听
	// onUnload() {
  //   wx.offThemeChange(this._handler)
  // }
})
```

* 页面实例被页面外变量或全局变量引用

``` javascript
// 函数闭包内持有了页面this，且函数被挂到全局或页面声明周期外的白能量， 会导致屋面无法释放

let launageListener = null

Page({
  onLoad() {
    getApp().userInfoChangeListener = ({userName}) => {
      this.setData({userName})
    }
    launageListener = ({lang}) => {
      this.setData({lang})
    }
  }
  // 修复方法， unload 中进行清理
  onUnload() {
  	getApp().userInfoChangeListener = null
  	launageListener = null
	}
})
```

* 页面实例被异步回调长时间引用

``` javascript
// 如果在长时间未返回的异步回调中访问了页面的this，如持续时间过长的 setTimeout 等耗时较长的 wx API 回调，（如长时间的 wx.request）, 会导致页面无法释放

Page({
  onLoad() {
    this._timer = setInterval(
    	() => {
        this.setData({
          timerValue: Date.now()
        })
      },
      1000
    )
  },
  // 修复方法，unload 中进行清理
  onUnload() {
    clearInterval(this._timer)
  }
})
```

